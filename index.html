<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Content Detector</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        textarea {
            width: 100%;
            height: 180px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 16px;
            resize: vertical;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 16px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .results {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            display: none;
        }

        .meter-container {
            width: 100%;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }

        .score-number {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: black;
            mix-blend-mode: difference;
            text-shadow: 0 0 3px white;
        }

        .scores-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .score-box {
            text-align: center;
            padding: 15px;
            border-radius: 4px;
            flex: 1;
            margin: 0 5px;
        }

        .ai-score {
            background-color: #ffecb3;
        }

        .human-score {
            background-color: #d5f5e3;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
        }

        .score-label {
            font-size: 14px;
            margin-top: 5px;
        }

        .indicators-section {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .indicators-column {
            flex: 1;
            padding: 15px;
            border-radius: 4px;
        }

        .ai-indicators {
            background-color: #fff8e1;
        }

        .human-indicators {
            background-color: #e8f5e9;
        }

        .critical-alert {
            background-color: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .calculation-info {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-size: 14px;
        }

        .sample-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .sample-button {
            background-color: #2ecc71;
            font-size: 14px;
            padding: 8px 12px;
        }

        .sample-button:hover {
            background-color: #27ae60;
        }

        .detailed-analysis {
            margin-top: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }

        .feature-score {
            font-weight: bold;
            color: #e74c3c;
        }

        .human-feature-score {
            font-weight: bold;
            color: #27ae60;
        }
    </style>
</head>

<body>
    <h1>Advanced AI Content Detector</h1>
    <p>Analyze text to determine if it was likely written by a human or generated by AI using deep linguistic analysis.</p>

    <div class="sample-buttons">
        <button class="sample-button" data-sample="formal-ai">Sample: Formal AI Style</button>
        <button class="sample-button" data-sample="personal">Sample: Personal Narrative</button>
        <button class="sample-button" data-sample="em-dash">Sample: Text with Em Dashes</button>
        <button class="sample-button" data-sample="title-case">Sample: Consistent Title Case</button>
        <button class="sample-button" data-sample="climate">Sample: Global Warming Text</button>
    </div>

    <textarea id="text-input"
        placeholder="Paste or type text to analyze (minimum 100 characters recommended)"></textarea>
    <button id="analyze-button">Analyze Text</button>

    <div id="results" class="results">
        <div id="critical-alert" class="critical-alert" style="display: none;">
            <h3>‚ö†Ô∏è Strong AI Indicators Detected</h3>
            <p id="critical-message">This text contains patterns strongly associated with AI-generated content.</p>
        </div>

        <h2>Analysis Results</h2>

        <div class="meter-container">
            <div id="meter-fill" class="meter-fill"></div>
            <div id="score-number" class="score-number">0%</div>
        </div>

        <h3 id="result-message">Analyzing...</h3>

        <div class="scores-container">
            <div class="score-box ai-score">
                <div id="ai-score" class="score-value">0.00</div>
                <div class="score-label">AI Score</div>
            </div>
            <div class="score-box human-score">
                <div id="human-score" class="score-value">0.00</div>
                <div class="score-label">Human Score</div>
            </div>
        </div>

        <div class="indicators-section">
            <div class="indicators-column ai-indicators">
                <h3>AI Indicators</h3>
                <ul id="ai-indicators-list">
                    <li>No strong AI indicators found</li>
                </ul>
            </div>
            <div class="indicators-column human-indicators">
                <h3>Human Indicators</h3>
                <ul id="human-indicators-list">
                    <li>No strong human indicators found</li>
                </ul>
            </div>
        </div>

        <div class="detailed-analysis">
            <h3>Detailed Language Analysis</h3>
            <div id="detailed-analysis-content"></div>
        </div>

        <div class="calculation-info">
            <h3>Score Calculation</h3>
            <p id="calculation-explanation">AI Score: 0.00, Human Score: 0.00</p>
            <p id="final-score-explanation">Final Score: 0%</p>
        </div>
    </div>

    <script>
        // Advanced AI Content Detector with Deep Linguistic Analysis
        function analyzeText(text) {
            // Results structure
            const results = {
                aiScore: 0,
                humanScore: 0,
                aiIndicators: [],
                humanIndicators: [],
                criticalIndicators: [],
                detailedAnalysis: []
            };

            // SURFACE PATTERN ANALYSIS
            
            // Check for em dashes (strong AI indicator)
            const emDashCount = countCharacter(text, '‚Äî');
            if (emDashCount > 0) {
                results.aiScore += 0.2 + (emDashCount * 0.02);
                results.aiIndicators.push(`Em dashes detected (${emDashCount})`);
                results.criticalIndicators.push(`Em dashes (${emDashCount})`);
            }

            // Check for trademark symbols
            const trademarkCount = (text.match(/[¬Æ¬©‚Ñ¢]/g) || []).length;
            if (trademarkCount > 0) {
                results.aiScore += 0.15;
                results.aiIndicators.push(`Trademark symbols detected (${trademarkCount})`);
                results.criticalIndicators.push(`Trademark symbols (${trademarkCount})`);
            }

            // Check for formal language
            const formalPhrases = ["furthermore", "moreover", "therefore", "consequently",
                "in conclusion", "in summary", "as a result"];
            const formalCount = countPhrases(text, formalPhrases);
            if (formalCount > 0) {
                results.aiScore += formalCount * 0.03;
                results.aiIndicators.push(`Formal transitional phrases detected (${formalCount})`);
                results.detailedAnalysis.push(`Formal transition phrases: <span class="feature-score">+${(formalCount * 0.03).toFixed(2)}</span>`);
            }

            // DEEP LINGUISTIC ANALYSIS

            // 1. Sentence Structure Analysis
            const sentenceStructure = analyzeSentenceStructure(text);
            if (sentenceStructure.detected) {
                results.aiScore += sentenceStructure.score;
                results.aiIndicators.push(sentenceStructure.message);
                results.detailedAnalysis.push(`Sentence structure: <span class="feature-score">+${sentenceStructure.score.toFixed(2)}</span> - ${sentenceStructure.detail}`);
            }

            // 2. Vocabulary Variety Analysis
            const vocabularyVariety = analyzeVocabularyVariety(text);
            if (vocabularyVariety.detected) {
                results.aiScore += vocabularyVariety.score;
                results.aiIndicators.push(vocabularyVariety.message);
                results.detailedAnalysis.push(`Vocabulary variety: <span class="feature-score">+${vocabularyVariety.score.toFixed(2)}</span> - ${vocabularyVariety.detail}`);
            }

            // 3. Transition Words Density
            const transitionDensity = analyzeTransitionDensity(text);
            if (transitionDensity.detected) {
                results.aiScore += transitionDensity.score;
                results.aiIndicators.push(transitionDensity.message);
                results.detailedAnalysis.push(`Transition density: <span class="feature-score">+${transitionDensity.score.toFixed(2)}</span> - ${transitionDensity.detail}`);
            }

            // 4. Paragraph Symmetry Analysis
            const paragraphSymmetry = analyzeParagraphSymmetry(text);
            if (paragraphSymmetry.detected) {
                results.aiScore += paragraphSymmetry.score;
                results.aiIndicators.push(paragraphSymmetry.message);
                results.detailedAnalysis.push(`Paragraph symmetry: <span class="feature-score">+${paragraphSymmetry.score.toFixed(2)}</span> - ${paragraphSymmetry.detail}`);
            }

            // 5. Topic Introduction Pattern
            const topicPattern = analyzeTopicIntroPattern(text);
            if (topicPattern.detected) {
                results.aiScore += topicPattern.score;
                results.aiIndicators.push(topicPattern.message);
                results.detailedAnalysis.push(`Topic introduction: <span class="feature-score">+${topicPattern.score.toFixed(2)}</span> - ${topicPattern.detail}`);
            }

            // 6. Sentence length variation (low variation is AI indicator)
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            if (sentences.length >= 3) {
                const lengths = sentences.map(s => s.split(/\s+/).length);
                const avg = lengths.reduce((sum, len) => sum + len, 0) / lengths.length;
                const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avg, 2), 0) / lengths.length;
                const stdDev = Math.sqrt(variance);

                results.detailedAnalysis.push(`Sentence length variation: Avg=${avg.toFixed(1)} words, StdDev=${stdDev.toFixed(1)}`);

                if (stdDev < 2.5 && sentences.length >= 5) {
                    results.aiScore += 0.2;
                    results.aiIndicators.push("Low sentence length variation");
                    results.detailedAnalysis.push(`Sentence variation: <span class="feature-score">+0.20</span> - Too consistent`);
                } else if (stdDev > 4) {
                    results.humanScore += 0.1;
                    results.humanIndicators.push("High sentence length variation");
                    results.detailedAnalysis.push(`Sentence variation: <span class="human-feature-score">+0.10 (human)</span> - Natural variation`);
                }
            }

            // 7. Title Case Consistency in Headers
            const titleCaseResult = checkTitleCaseConsistency(text);
            if (titleCaseResult.detected) {
                results.aiScore += titleCaseResult.score;
                results.aiIndicators.push(titleCaseResult.message);
                results.detailedAnalysis.push(`Title case usage: <span class="feature-score">+${titleCaseResult.score.toFixed(2)}</span> - ${titleCaseResult.detail || 'Consistently capitalized'}`);
            }

            // 8. List Punctuation Consistency
            const listPunctuationResult = checkListPunctuationConsistency(text);
            if (listPunctuationResult.detected) {
                results.aiScore += listPunctuationResult.score;
                results.aiIndicators.push(listPunctuationResult.message);
                results.detailedAnalysis.push(`List punctuation: <span class="feature-score">+${listPunctuationResult.score.toFixed(2)}</span> - ${listPunctuationResult.detail || 'Too consistent'}`);
            }

            // HUMAN INDICATORS

            // Check for personal language (human indicator)
            const personalPhrases = ["i ", "me ", "my ", "we ", "our ", "honestly", "personally",
                "i think", "i feel", "i've", "i'm", "we've"];
            const personalCount = countPhrases(text, personalPhrases);
            if (personalCount > 0) {
                const personalScore = Math.min(0.2, personalCount * 0.04);
                results.humanScore += personalScore;
                results.humanIndicators.push(`Personal language detected (${personalCount})`);
                results.detailedAnalysis.push(`Personal language: <span class="human-feature-score">+${personalScore.toFixed(2)} (human)</span>`);
            }

            // Check for emotional expressions (human indicator)
            const emotionalCount = (text.match(/!+|\?+|[A-Z]{3,}|üòä|üòÇ|üòÅ|üòÑ|üòÉ|üòÄ|üòç|‚ù§Ô∏è|üëç|üôå/g) || []).length;
            if (emotionalCount > 0) {
                const emotionalScore = Math.min(0.15, emotionalCount * 0.03);
                results.humanScore += emotionalScore;
                results.humanIndicators.push(`Emotional expressions detected (${emotionalCount})`);
                results.detailedAnalysis.push(`Emotional expressions: <span class="human-feature-score">+${emotionalScore.toFixed(2)} (human)</span>`);
            }

            // Irregularity in writing (human indicator)
            const misspellings = detectMisspellings(text);
            if (misspellings > 0) {
                const misspellScore = Math.min(0.25, misspellings * 0.05);
                results.humanScore += misspellScore;
                results.humanIndicators.push(`Likely spelling variations detected (${misspellings})`);
                results.detailedAnalysis.push(`Spelling variations: <span class="human-feature-score">+${misspellScore.toFixed(2)} (human)</span>`);
            }

            // Reduce human score if critical AI indicators are present
            if (emDashCount > 0 || trademarkCount > 0) {
                results.humanScore = Math.max(0, results.humanScore - 0.1);
            }

            // Calculate final score - more aggressive with AI scoring
            let finalScore = 0;

            // FIX: Make sure to handle the case where AI score is 0
            if (results.aiScore <= 0.01) {
                // If AI score is 0 or negligible
                if (results.humanScore <= 0.01) {
                    // If both scores are 0, assign a default small human score
                    // This handles the edge case of neutral text
                    results.humanScore = 0.1;
                    results.humanIndicators.push("Default human authorship assumption");
                    results.detailedAnalysis.push(`Default human assumption: <span class="human-feature-score">+0.10 (human)</span> - No strong patterns detected`);
                    
                    // Set final score to indicate human content
                    finalScore = 0.05;
                } else {
                    // If only AI score is 0, set a very low final score
                    finalScore = 0.05;
                }
            } else if (results.humanScore <= 0.01) {
                // If human score is 0 or negligible, set a very high final score
                finalScore = 0.95;
            } else if (results.aiScore > results.humanScore) {
                // Scale to 0.6-1.0 range based on the difference (more aggressive)
                const difference = results.aiScore - results.humanScore;
                finalScore = 0.6 + (difference * 0.4);
            } else {
                // Make it harder to be classified as human
                const difference = results.humanScore - results.aiScore;
                finalScore = 0.4 - (difference * 0.4);
            }

            // Clamp between 0 and 1
            finalScore = Math.max(0, Math.min(1, finalScore));

            // FIX: Generate interpretation based on actual scores, not just final percentage
            let interpretation;
            if (results.aiScore <= 0.01) {
                // If no AI indicators were found at all
                interpretation = "Very likely human-written content.";
            } else if (results.humanScore <= 0.01) {
                // If no human indicators were found at all
                interpretation = "Very likely AI-generated content.";
            } else if (finalScore > 0.8) {
                interpretation = "Very likely AI-generated content.";
            } else if (finalScore > 0.6) {
                interpretation = "Likely AI-generated content.";
            } else if (finalScore > 0.4) {
                interpretation = "Possibly AI-generated content with some human editing.";
            } else if (finalScore > 0.2) {
                interpretation = "Likely human-written content with some AI-like patterns.";
            } else {
                interpretation = "Very likely human-written content.";
            }

            return {
                score: finalScore,
                aiScore: results.aiScore,
                humanScore: results.humanScore,
                message: interpretation,
                aiIndicators: results.aiIndicators,
                humanIndicators: results.humanIndicators,
                criticalIndicators: results.criticalIndicators,
                detailedAnalysis: results.detailedAnalysis,
                calculationExplanation: `AI Score (${results.aiScore.toFixed(2)}) vs Human Score (${results.humanScore.toFixed(2)})`
            };
        }

        // 1. Sentence Structure Analysis
        function analyzeSentenceStructure(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            if (sentences.length < 4) return { detected: false };
            
            // Calculate subject-verb-object patterns
            const patterns = [];
            let simpleStructureCount = 0;
            
            sentences.forEach(sentence => {
                const words = sentence.trim().split(/\s+/);
                // Check for simple "subject is/are object" structure
                const simplePattern = /\b(is|are|was|were)\b/i.test(sentence);
                if (simplePattern) simpleStructureCount++;
                
                // Create a simple pattern signature based on sentence structure
                const hasConjunction = /\b(and|but|or|because|however|therefore)\b/i.test(sentence);
                const hasPreposition = /\b(in|on|at|by|with|from|to|for)\b/i.test(sentence);
                const pattern = `${words.length < 10 ? 'S' : 'L'}-${hasConjunction ? 'C' : 'N'}-${hasPreposition ? 'P' : 'N'}`;
                patterns.push(pattern);
            });
            
            // Count pattern repetitions
            const patternCounts = {};
            patterns.forEach(p => {
                patternCounts[p] = (patternCounts[p] || 0) + 1;
            });
            
            // Calculate most common pattern percentage
            const mostCommonPattern = Object.entries(patternCounts).sort((a, b) => b[1] - a[1])[0];
            const dominantPatternPercentage = mostCommonPattern ? mostCommonPattern[1] / patterns.length : 0;
            
            // Check if simple structures dominate
            const simpleStructurePercentage = simpleStructureCount / sentences.length;
            
            if (dominantPatternPercentage > 0.5 || simpleStructurePercentage > 0.6) {
                return {
                    detected: true,
                    score: 0.25,
                    message: "Repetitive sentence structure patterns",
                    detail: `${Math.round(Math.max(dominantPatternPercentage, simpleStructurePercentage) * 100)}% similar structures`
                };
            }
            
            return { detected: false };
        }

        // 2. Vocabulary Variety Analysis
        function analyzeVocabularyVariety(text) {
            // Remove common stop words
            const stopWords = ["the", "and", "a", "to", "of", "in", "that", "is", "it", "for", "with", "as", "on", "by", "this", "be", "are", "an"];
            
            // Get all meaningful words (3+ chars)
            const words = text.toLowerCase().match(/\b[a-z]{3,}\b/g) || [];
            if (words.length < 50) return { detected: false }; // Need enough words
            
            // Filter out stop words
            const contentWords = words.filter(word => !stopWords.includes(word));
            
            // Calculate lexical variety
            const uniqueWords = new Set(contentWords);
            const lexicalVariety = uniqueWords.size / contentWords.length;
            
            // Check for repeated phrases (3+ words)
            const threeGrams = [];
            for (let i = 0; i < contentWords.length - 2; i++) {
                threeGrams.push(`${contentWords[i]} ${contentWords[i+1]} ${contentWords[i+2]}`);
            }
            
            const uniqueThreeGrams = new Set(threeGrams);
            const phraseVariety = uniqueThreeGrams.size / (threeGrams.length || 1);
            
            if (lexicalVariety < 0.6 && contentWords.length > 50) {
                return {
                    detected: true,
                    score: 0.2,
                    message: "Limited vocabulary variety",
                    detail: `${Math.round(lexicalVariety * 100)}% unique content words`
                };
            }
            
            if (phraseVariety < 0.8 && threeGrams.length > 20) {
                return {
                    detected: true,
                    score: 0.15,
                    message: "Repeated phrase patterns detected",
                    detail: `${Math.round(phraseVariety * 100)}% unique phrases`
                };
            }
            
            return { detected: false };
        }

        // 3. Transition Words Density
        function analyzeTransitionDensity(text) {
            const transitions = ["however", "therefore", "because", "additionally", "furthermore", 
                                "consequently", "thus", "despite", "although", "nevertheless",
                                "moreover", "subsequently", "indeed", "hence", "then", "meanwhile"];
            const lowerText = text.toLowerCase();
            
            let count = 0;
            const foundTransitions = [];
            
            transitions.forEach(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'g');
                const matches = lowerText.match(regex) || [];
                if (matches.length > 0) {
                    foundTransitions.push(`${word} (${matches.length})`);
                }
                count += matches.length;
            });
            
            const wordCount = text.split(/\s+/).length;
            const density = (count / wordCount) * 100; // Percentage of words that are transitions
            
            if (density > 2.5 && wordCount > 100) {
                return {
                    detected: true,
                    score: 0.2,
                    message: `High transition word density (${density.toFixed(1)}%)`,
                    detail: `Found: ${foundTransitions.slice(0, 3).join(", ")}${foundTransitions.length > 3 ? ', etc.' : ''}`
                };
            }
            
            return { detected: false };
        }

        // 4. Paragraph Symmetry Analysis
        function analyzeParagraphSymmetry(text) {
            const paragraphs = text.split(/\r?\n/).filter(p => p.trim().length > 0);
            if (paragraphs.length < 3) return { detected: false };
            
            const lengths = paragraphs.map(p => p.split(/\s+/).length);
            const avg = lengths.reduce((sum, len) => sum + len, 0) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avg, 2), 0) / lengths.length;
            const stdDev = Math.sqrt(variance);
            
            const variationCoefficient = stdDev / avg;
            
            if (variationCoefficient < 0.3 && paragraphs.length >= 4) {
                return {
                    detected: true,
                    score: 0.15,
                    message: "Unusually consistent paragraph lengths",
                    detail: `Variation coefficient: ${variationCoefficient.toFixed(2)} (human texts typically > 0.4)`
                };
            }
            
            return { detected: false };
        }

        // 5. Topic Introduction Pattern
        function analyzeTopicIntroPattern(text) {
            const paragraphs = text.split(/\r?\n/).filter(p => p.trim().length > 3);
            if (paragraphs.length < 3) return { detected: false };
            
            // Count AI-like topic introduction patterns
            let topicIntroCount = 0;
            let patternDetails = [];
            
            paragraphs.forEach(para => {
                const firstSentence = para.split(/[.!?]/).filter(s => s.trim())[0] || "";
                const startsWithTopic = /^[A-Z][a-z]+ (is|are|can|will|may|might|should|could|has|have|had|helps|makes|causes)/i.test(firstSentence.trim());
                
                if (startsWithTopic) {
                    topicIntroCount++;
                    if (patternDetails.length < 2) {
                        patternDetails.push(firstSentence.trim().substring(0, 40) + (firstSentence.length > 40 ? "..." : ""));
                    }
                }
            });
            
            const patternPercentage = topicIntroCount / paragraphs.length;
            
            if (patternPercentage > 0.6 && paragraphs.length >= 3) {
                return {
                    detected: true,
                    score: 0.2,
                    message: "AI-like topic introduction pattern",
                    detail: `${Math.round(patternPercentage * 100)}% of paragraphs follow predictable subject-verb pattern`
                };
            }
            
            return { detected: false };
        }

        // Check for consistent title case in headings
        function checkTitleCaseConsistency(text) {
            // Look for heading patterns (lines that start with capital letters)
            const lines = text.split('\n');
            const headingLines = lines.filter(line => 
                line.trim().length > 0 && 
                /^[A-Z]/.test(line.trim()) && 
                line.split(/\s+/).length >= 2 &&
                line.split(/\s+/).length <= 8 &&
                !line.trim().endsWith('.')
            );
            
            if (headingLines.length >= 2) {
                // Count words that follow Title Case pattern
                let titleCaseWords = 0;
                let totalWords = 0;
                
                headingLines.forEach(line => {
                    const words = line.trim().split(/\s+/);
                    totalWords += words.length;
                    
                    // Skip first word and small words (naturally capitalized) and count rest
                    for (let i = 1; i < words.length; i++) {
                        const word = words[i];
                        if (word.length > 3 && /^[A-Z][a-z]+$/.test(word)) {
                            titleCaseWords++;
                        }
                    }
                });
                
                // Calculate percentage of words that follow title case (excluding first words)
                const potentialTitleCaseWords = totalWords - headingLines.length;
                const titleCasePercentage = potentialTitleCaseWords > 0 
                    ? titleCaseWords / potentialTitleCaseWords 
                    : 0;
                
                // If over 80% of non-first words use Title Case, flag it
                if (totalWords > 8 && titleCasePercentage > 0.8) {
                    return {
                        detected: true,
                        score: 0.15,
                        message: `Consistent title case in headings (${Math.round(titleCasePercentage * 100)}%)`,
                        detail: `${titleCaseWords} of ${potentialTitleCaseWords} words consistently capitalized`
                    };
                }
            }
            
            return { detected: false };
        }

        // Check for consistent list punctuation
        function checkListPunctuationConsistency(text) {
            // Find list items (lines starting with bullet points, numbers, or dashes)
            const listItemRegex = /^\s*[-‚Ä¢*]|^\s*\d+[.)]\s+.+/gm;
            const listItems = text.match(listItemRegex);
            
            if (listItems && listItems.length >= 3) {
                // Get the corresponding full lines
                const lines = text.split('\n');
                const listLines = lines.filter(line => 
                    line.trim().match(/^\s*[-‚Ä¢*]|^\s*\d+[.)]\s+.+/)
                );
                
                // Count items ending with periods and without periods
                const endsWithPeriod = listLines.filter(
                    line => /[.!?]$/.test(line.trim())
                ).length;
                
                const endsWithoutPeriod = listLines.filter(
                    line => !/[.!?]$/.test(line.trim()) && line.trim().length > 0
                ).length;
                
                // Calculate consistency ratio
                const totalItems = endsWithPeriod + endsWithoutPeriod;
                const consistency = Math.max(endsWithPeriod, endsWithoutPeriod) / totalItems;
                
                // If all list items are consistently punctuated (or not), flag it
                if (totalItems >= 3 && consistency > 0.9) {
                    return {
                        detected: true,
                        score: 0.15,
                        message: `Consistently ${endsWithPeriod > endsWithoutPeriod ? 
                            'punctuated' : 'unpunctuated'} list items (${Math.round(consistency * 100)}%)`,
                        detail: `${Math.max(endsWithPeriod, endsWithoutPeriod)} of ${totalItems} items follow the same pattern`
                    };
                }
            }
            
            return { detected: false };
        }

        // Detect likely spelling variations or errors (human indicator)
        function detectMisspellings(text) {
            // Simple heuristic to detect potential misspellings
            // AI tends to have fewer spelling issues
            const words = text.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
            const commonMisspellings = [
                { correct: "their", variant: "thier" },
                { correct: "they're", variant: "theyre" },
                { correct: "receive", variant: "recieve" },
                { correct: "separate", variant: "seperate" },
                { correct: "definitely", variant: "definately" },
                { correct: "necessary", variant: "neccessary" },
                { correct: "occurred", variant: "occured" },
                { correct: "government", variant: "goverment" },
                { correct: "argument", variant: "arguement" },
                { correct: "beginning", variant: "begining" },
                { correct: "believe", variant: "beleive" },
                { correct: "convenient", variant: "conveniant" },
                { correct: "experience", variant: "experiance" }
            ];
            
            let misspellingCount = 0;
            
            // Check for doubled words (e.g., "the the")
            const text_words = text.toLowerCase().split(/\s+/);
            for (let i = 1; i < text_words.length; i++) {
                if (text_words[i].length > 2 && text_words[i] === text_words[i-1]) {
                    misspellingCount++;
                }
            }
            
            // Check against common misspellings
            commonMisspellings.forEach(pair => {
                if (text.toLowerCase().includes(pair.variant)) {
                    misspellingCount++;
                }
            });
            
            // Check for unusual contractions or missing apostrophes
            const contractionPatterns = [/\b(cant|wont|doesnt|didnt|isnt|arent|wouldnt|couldnt|shouldnt|hadnt|hasnt|havent|dont)\b/g];
            contractionPatterns.forEach(pattern => {
                const matches = text.toLowerCase().match(pattern) || [];
                misspellingCount += matches.length;
            });
            
            return misspellingCount;
        }

        // Helper function to count character occurrences
        function countCharacter(text, char) {
            let count = 0;
            for (let i = 0; i < text.length; i++) {
                if (text[i] === char) count++;
            }
            return count;
        }

        // Helper function to count phrases
        function countPhrases(text, phrases) {
            const lowerText = text.toLowerCase();
            return phrases.filter(phrase => lowerText.includes(phrase)).length;
        }

        // DOM Elements
        const textInput = document.getElementById('text-input');
        const analyzeButton = document.getElementById('analyze-button');
        const resultsDiv = document.getElementById('results');
        const meterFill = document.getElementById('meter-fill');
        const scoreNumber = document.getElementById('score-number');
        const resultMessage = document.getElementById('result-message');
        const aiScore = document.getElementById('ai-score');
        const humanScore = document.getElementById('human-score');
        const aiIndicatorsList = document.getElementById('ai-indicators-list');
        const humanIndicatorsList = document.getElementById('human-indicators-list');
        const criticalAlert = document.getElementById('critical-alert');
        const criticalMessage = document.getElementById('critical-message');
        const calculationExplanation = document.getElementById('calculation-explanation');
        const finalScoreExplanation = document.getElementById('final-score-explanation');
        const detailedAnalysisContent = document.getElementById('detailed-analysis-content');

        // Sample texts
        const sampleTexts = {
            'formal-ai': `The impact of climate change on global ecosystems is profound and far-reaching. As a result of increasing temperatures, many species are experiencing habitat loss. Furthermore, ocean acidification threatens marine biodiversity. Studies show that carbon emissions continue to rise despite international agreements. Therefore, immediate action is necessary to mitigate these effects. In conclusion, the future of our planet depends on sustainable practices and policy changes.`,

            'personal': `I went hiking last weekend and saw the most beautiful sunset ever! My friends and I had been planning this trip for weeks. When I reached the summit, the view took my breath away. Today I'm still sore from the climb, but it was totally worth it. Yesterday I showed the photos to my mom and she loved them. We're definitely going back there next summer.`,

            'em-dash': `The future of work‚Äîinfluenced by automation, remote collaboration, and artificial intelligence‚Äîis rapidly evolving. Companies must adapt‚Äîespecially in knowledge-intensive industries‚Äîto remain competitive. This adaptation requires three key strategies: workforce reskilling, technological infrastructure enhancement, and organizational culture transformation.`,
            
            'title-case': `Top Benefits Of Regular Exercise
Cardiovascular Health Improvement
Muscle Strength And Endurance
Weight Management And Fat Loss
Mental Health And Cognitive Benefits
Improved Sleep Quality
Reduced Risk Of Chronic Diseases`,

            'climate': `Global warming is making the Earth hotter, and this is changing our environment in many ways. One big change is the weather. Some places are getting too much rain and flooding, while others are getting very dry with no rain at all. This makes it hard for animals, plants, and people to live.

Another problem is that ice in the North and South Poles is melting. This causes sea levels to rise, which can flood cities near the ocean. Animals like polar bears and penguins are losing their homes because the ice they live on is disappearing.

Forests are also in danger. The hot weather makes it easier for wildfires to start, burning down trees and making the air dirty with smoke. Trees help clean the air, so losing them makes the air worse for us to breathe.

Oceans are also getting warmer, which is bad for sea animals. Coral reefs, which are homes for many fish, are dying because of the heat. Some fish are moving to cooler waters, which can make it hard for people who fish for food.

Global warming is happening because people burn too much coal, oil, and gas, which put bad gases into the air. These gases trap heat and make the Earth hotter. To stop this, we need to use clean energy like wind and solar power, plant more trees, and waste less.`
        };

        // Load sample text
        document.querySelectorAll('.sample-button').forEach(button => {
            button.addEventListener('click', () => {
                const sampleKey = button.getAttribute('data-sample');
                textInput.value = sampleTexts[sampleKey];
            });
        });

        // Update indicators list
        function updateList(list, indicators) {
            list.innerHTML = '';

            if (!indicators || indicators.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No strong indicators found';
                list.appendChild(li);
                return;
            }

            indicators.forEach(indicator => {
                const li = document.createElement('li');
                li.textContent = indicator;
                list.appendChild(li);
            });
        }

        // Handle analysis
        analyzeButton.addEventListener('click', () => {
            const text = textInput.value.trim();

            if (text.length < 100) {
                alert("Please enter at least 100 characters for reliable analysis.");
                return;
            }

            // Analyze the text
            const result = analyzeText(text);

            // Show results
            resultsDiv.style.display = 'block';

            // Update score visualization
            const scorePercent = Math.round(result.score * 100);
            meterFill.style.width = `${scorePercent}%`;
            scoreNumber.textContent = `${scorePercent}%`;

            // Set color based on AI likelihood
            if (scorePercent < 30) {
                meterFill.style.backgroundColor = '#2ecc71'; // Green (human)
            } else if (scorePercent < 50) {
                meterFill.style.backgroundColor = '#f1c40f'; // Yellow (somewhat human)
            } else if (scorePercent < 70) {
                meterFill.style.backgroundColor = '#e67e22'; // Orange (somewhat AI)
            } else {
                meterFill.style.backgroundColor = '#e74c3c'; // Red (AI)
            }

            // Update scores and message
            resultMessage.textContent = result.message;
            aiScore.textContent = result.aiScore.toFixed(2);
            humanScore.textContent = result.humanScore.toFixed(2);

            // Update indicators
            updateList(aiIndicatorsList, result.aiIndicators);
            updateList(humanIndicatorsList, result.humanIndicators);

            // Update detailed analysis
            if (result.detailedAnalysis && result.detailedAnalysis.length > 0) {
                detailedAnalysisContent.innerHTML = result.detailedAnalysis.join('<br>');
            } else {
                detailedAnalysisContent.innerHTML = 'No detailed analysis available.';
            }

            // Show critical alert if needed
            if (result.criticalIndicators && result.criticalIndicators.length > 0) {
                criticalAlert.style.display = 'block';
                criticalMessage.textContent = `This text contains: ${result.criticalIndicators.join(', ')}. These are strong indicators of AI-generated content.`;
            } else {
                criticalAlert.style.display = 'none';
            }

            // Update calculation explanation
            calculationExplanation.textContent = result.calculationExplanation;
            finalScoreExplanation.textContent = `Final Score: ${scorePercent}% (${result.aiScore > result.humanScore ? 'AI > Human' : 'Human > AI'})`;
        });
    </script>
</body>

</html>
